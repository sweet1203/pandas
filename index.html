<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>CSV 데이터 분석기</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Malgun Gothic', '맑은 고딕', 'Noto Sans KR', sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 2rem;
      text-align: center;
    }
    
    .header h1 {
      margin: 0;
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }
    
    .header p {
      margin: 0;
      opacity: 0.9;
    }
    
    .content {
      padding: 2rem;
    }
    
    .file-upload {
      border: 3px dashed #667eea;
      border-radius: 15px;
      padding: 3rem 2rem;
      text-align: center;
      margin-bottom: 2rem;
      background-color: #f8f9ff;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .file-upload:hover {
      background-color: #e8ecff;
      border-color: #5a6fd8;
    }
    
    .file-upload.dragover {
      background-color: #e8ecff;
      border-color: #5a6fd8;
      transform: scale(1.02);
    }
    
    .file-upload i {
      font-size: 3rem;
      color: #667eea;
      margin-bottom: 1rem;
      display: block;
    }
    
    .file-upload p {
      font-size: 1.1rem;
      color: #666;
      margin: 0;
    }
    
    .file-upload .small {
      font-size: 0.9rem;
      color: #999;
      margin-top: 0.5rem;
    }
    
    .analysis-result {
      margin-top: 2rem;
      padding: 1.5rem;
      background: #f8f9ff;
      border-radius: 10px;
      border: 1px solid #e8ecff;
      display: none;
    }
    
    .analysis-result h3 {
      color: #667eea;
      margin-top: 0;
      margin-bottom: 1rem;
      text-align: center;
    }
    
    .analysis-result table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
      min-width: 600px;
    }
    
    .analysis-result th {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
    }
    
    .analysis-result td {
      padding: 10px 8px;
      text-align: center;
      border-bottom: 1px solid #eee;
    }
    
    .analysis-result tr:nth-child(even) {
      background-color: #f8f9ff;
    }
    
    .analysis-result tr:hover {
      background-color: #e8ecff;
    }
    
    .loading {
      text-align: center;
      color: #667eea;
      font-weight: bold;
      padding: 2rem;
    }
    
    .loading i {
      font-size: 2rem;
      margin-bottom: 1rem;
    }
    
    .error {
      background: #ffe6e6;
      color: #d63031;
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid #ff7675;
      text-align: center;
    }
    
    .info-box {
      background: #e8f4fd;
      border: 1px solid #b3d9ff;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 2rem;
    }
    
    .info-box h4 {
      color: #0066cc;
      margin-top: 0;
    }
    
    .info-box ul {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }
    
    .info-box li {
      margin-bottom: 0.3rem;
    }
    
    .table-container {
      overflow-x: auto;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
    }
    
    /* PDF 출력 버튼 스타일 */
    .pdf-export {
      text-align: center;
      margin-top: 2rem;
      padding: 1rem;
      background: #f8f9ff;
      border-radius: 10px;
      border: 1px solid #e8ecff;
    }
    
    .pdf-export button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }
    
    .pdf-export button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    .pdf-export button:active {
      transform: translateY(0);
    }
    
    /* 인쇄 스타일 */
    @media print {
      body {
        background: white !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      
      .container {
        box-shadow: none !important;
        border-radius: 0 !important;
        max-width: none !important;
      }
      
      .header {
        background: #667eea !important;
        color: white !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      
      .file-upload,
      .info-box,
      .pdf-export {
        display: none !important;
      }
      
      .content {
        padding: 1rem !important;
      }
      
      .analysis-result {
        display: block !important;
        background: white !important;
        border: none !important;
        padding: 0 !important;
      }
      
      .analysis-result table {
        box-shadow: none !important;
        border: 1px solid #ddd !important;
      }
      
      .analysis-result th {
        background: #667eea !important;
        color: white !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      
      .table-container {
        box-shadow: none !important;
        border: 1px solid #ddd !important;
      }
      
      /* 페이지 나누기 방지 */
      .analysis-result h3 {
        page-break-after: avoid;
      }
      
      .analysis-result table {
        page-break-inside: avoid;
      }
    }
    
    @media (max-width: 768px) {
      .container {
        margin: 0;
        border-radius: 0;
      }
      
      .header {
        padding: 1.5rem;
      }
      
      .header h1 {
        font-size: 1.5rem;
      }
      
      .content {
        padding: 1rem;
      }
      
      .file-upload {
        padding: 2rem 1rem;
      }
      
      .analysis-result table {
        font-size: 0.8rem;
      }
      
      .analysis-result th,
      .analysis-result td {
        padding: 6px 4px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>📊 CSV 데이터 분석기</h1>
      <p>pandas info(), describe(), 결측치 분석 및 처리를 웹에서 사용해보세요</p>
    </div>
    
    <div class="content">
      <div class="info-box">
        <h4>📋 사용 방법</h4>
        <ul>
          <li><strong>1. 파일 업로드</strong>: CSV 파일을 드래그하거나 클릭하여 업로드</li>
          <li><strong>2. 데이터 정보 확인</strong>: 컬럼별 데이터 타입, 메모리 사용량 등 상세 정보</li>
          <li><strong>3. 결측치 분석</strong>: 각 컬럼별 결측치 개수와 비율을 시각적으로 확인</li>
          <li><strong>4. 결측치 처리</strong>: 삭제, 평균값 대체, 최빈값 대체 중 선택</li>
          <li><strong>5. 통계 분석</strong>: pandas describe()와 동일한 통계 정보 (count, mean, std, min, 25%, 50%, 75%, max)</li>
          <li><strong>6. 특정 열 분석</strong>: 원하는 컬럼만 선택하여 상세 분석</li>
        </ul>
        
        <h4>⚠️ 주의사항</h4>
        <ul>
          <li><strong>엑셀 파일 사용 시:</strong> "다른 이름으로 저장" → "파일 형식: CSV UTF-8"로 저장해주세요</li>
          <li>한글 깨짐 방지를 위해 UTF-8 인코딩을 권장합니다</li>
          <li>대용량 파일(100MB 이상)은 처리 시간이 오래 걸릴 수 있습니다</li>
        </ul>
      </div>
      
      <div class="file-upload" id="fileUpload">
        <i class="fas fa-cloud-upload-alt"></i>
        <p>📁 CSV 파일을 여기에 드래그하거나 클릭하여 업로드하세요</p>
        <p class="small">💡 지원 형식: .csv 파일</p>
        <input type="file" id="csvFile" accept=".csv" style="display: none;">
      </div>
      
      <div id="loadingIndicator" class="loading" style="display: none;">
        <i class="fas fa-spinner fa-spin"></i>
        <p>데이터를 분석하고 있습니다...</p>
      </div>
      
      <div id="analysisResult" class="analysis-result"></div>
    </div>
  </div>
  
  <!-- 제작자 정보 -->
  <div style="text-align: center; padding: 20px; margin-top: 20px; color: #666; font-size: 0.9rem; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Malgun Gothic', '맑은 고딕', 'Noto Sans KR', sans-serif;">
    <div style="background: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); display: inline-block;">
      <span style="color: #ff69b4;">💖</span>
      <strong style="color: #333;">대성여고 정보쌤 제작</strong>
      <span style="color: #ff69b4;">💖</span>
    </div>
  </div>

  <script>
    let globalData = null; // 전역 변수로 데이터 저장
    let globalInfoData = null;
    let originalData = null; // 원본 데이터 보존

    function calculateInfo(data) {
      const info = {
        totalRows: data.length - 1,
        totalColumns: data[0].length,
        columns: []
      };

      data[0].forEach((header, index) => {
        let nonNullCount = 0;
        let numericCount = 0;
        
        for (let i = 1; i < data.length; i++) {
          const cellValue = data[i][index];
          if (cellValue && cellValue.toString().trim() !== '') {
            nonNullCount++;
            if (!isNaN(parseFloat(cellValue))) {
              numericCount++;
            }
          }
        }

        const dtype = (nonNullCount > 0 && (numericCount / nonNullCount) >= 0.5) ? 'float64' : 'object';
        
        info.columns.push({
          name: header,
          nonNullCount: nonNullCount,
          dtype: dtype
        });
      });

      // 메모리 사용량 계산 (대략적인 추정)
      info.memoryUsage = ((info.totalRows * info.totalColumns * 8) / 1024).toFixed(2);

      return info;
    }

    function calculateDescribe(data, selectedColumn = null) {
      console.log('=== calculateDescribe 함수 시작 ===');
      console.log('입력 데이터:', data ? data.length : 'null', '행');
      console.log('선택된 열:', selectedColumn);
      
      const numericColumns = [];
      const results = {};

      // 숫자형 컬럼 찾기 (캐싱 활용)
      if (!data._numericColumnsCache) {
        console.log('캐시가 없어서 새로 계산합니다.');
        data._numericColumnsCache = [];
        console.log('=== 숫자형 컬럼 찾기 시작 ===');
        console.log('총 컬럼 수:', data[0].length);
        console.log('총 행 수:', data.length);
        console.log('헤더 행:', data[0]);
        
        if (!data[0] || !Array.isArray(data[0])) {
          console.error('❌ data[0]이 배열이 아닙니다:', data[0]);
          return results;
        }
        
        data[0].forEach((header, index) => {
          let numericCount = 0;
          let totalValidCount = 0;
          
          console.log(`\n--- 컬럼 ${index}: ${header} 분석 ---`);
          
          // 전체 데이터를 확인하여 숫자형 여부 판단
          for (let i = 1; i < data.length; i++) {
            const cellValue = data[i][index];
            if (cellValue && cellValue.toString().trim() !== '') {
              totalValidCount++;
              const numValue = parseFloat(cellValue);
              if (!isNaN(numValue)) {
                numericCount++;
                if (numericCount <= 3) {
                  console.log(`  행 ${i}: "${cellValue}" → ${numValue} (숫자)`);
                }
              } else {
                if (totalValidCount - numericCount <= 3) {
                  console.log(`  행 ${i}: "${cellValue}" → 숫자 아님`);
                }
              }
            }
          }
          
          console.log(`컬럼 ${index} 결과: 숫자 ${numericCount}개, 총 유효값 ${totalValidCount}개`);
          
          // 유효한 값 중 50% 이상이 숫자인 경우 숫자형 컬럼으로 인식
          if (totalValidCount > 0 && (numericCount / totalValidCount) >= 0.5) {
            data._numericColumnsCache.push(index);
            console.log(`✅ 컬럼 ${index} (${header}): 숫자형으로 인식 (${numericCount}/${totalValidCount})`);
          } else {
            console.log(`❌ 컬럼 ${index} (${header}): 문자열형으로 인식 (${numericCount}/${totalValidCount})`);
          }
        });
        
        console.log('=== 숫자형 컬럼 찾기 완료 ===');
        console.log('숫자형 컬럼 인덱스:', data._numericColumnsCache);
      }

      // 특정 열을 선택한 경우와 전체 열 분석을 구분
      let columnsToProcess = [];
      if (selectedColumn !== null && selectedColumn !== '') {
        // 특정 열을 선택한 경우, 해당 열만 분석
        const columnIndex = parseInt(selectedColumn);
        if (!isNaN(columnIndex) && columnIndex >= 0 && columnIndex < data[0].length) {
          columnsToProcess = [columnIndex];
          console.log(`특정 열 ${columnIndex} 선택됨: ${data[0][columnIndex]}`);
        } else {
          console.log(`잘못된 열 인덱스: ${selectedColumn}, 전체 열 분석으로 변경`);
          columnsToProcess = data._numericColumnsCache;
        }
      } else {
        // 전체 열 분석의 경우, 숫자형 컬럼만 분석
        columnsToProcess = data._numericColumnsCache;
        console.log('전체 열 분석 모드');
      }

      // 각 선택된 컬럼에 대해 describe 계산
      columnsToProcess.forEach(colIndex => {
        const columnName = data[0][colIndex];
        const values = [];
        
        console.log(`컬럼 ${colIndex} (${columnName}) 분석 시작`);
        
        // 숫자형 데이터 수집
        for (let i = 1; i < data.length; i++) {
          const cellValue = data[i][colIndex];
          if (cellValue && cellValue.toString().trim() !== '') {
            const numValue = parseFloat(cellValue);
            if (!isNaN(numValue)) {
              values.push(numValue);
              if (values.length <= 3) {
                console.log(`  행 ${i}: "${cellValue}" → ${numValue} (숫자로 변환됨)`);
              }
            } else {
              if (values.length <= 3) {
                console.log(`  행 ${i}: "${cellValue}" → 숫자 변환 실패`);
              }
            }
          }
        }

        console.log(`컬럼 ${columnName}: 총 ${values.length}개의 숫자 데이터 수집됨`);

        // 숫자형 데이터가 있는 경우에만 결과 추가
        if (values.length > 0) {
          values.sort((a, b) => a - b);
          const count = values.length;
          const mean = values.reduce((a, b) => a + b, 0) / count;
          const std = Math.sqrt(values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / count);
          
          results[columnName] = {
            count: count,
            mean: mean.toFixed(2),
            std: std.toFixed(2),
            min: values[0].toFixed(2),
            '25%': values[Math.floor(count * 0.25)].toFixed(2),
            '50%': values[Math.floor(count * 0.5)].toFixed(2),
            '75%': values[Math.floor(count * 0.75)].toFixed(2),
            max: values[values.length - 1].toFixed(2)
          };
          
          console.log(`컬럼 ${columnName} 분석 완료: ${count}개 데이터`);
        } else {
          console.log(`컬럼 ${columnName}: 숫자 데이터 없음`);
        }
      });

      return results;
    }

    function calculateMissingData(data) {
      // 마지막 행이 완전히 비어있으면 제거
      let cleanData = [...data];
      if (cleanData.length > 1) {
        const lastRow = cleanData[cleanData.length - 1];
        const isLastRowEmpty = lastRow.every(cell => cell === null || cell === undefined || cell === '' || (typeof cell === 'string' && cell.trim() === ''));
        if (isLastRowEmpty) {
          cleanData = cleanData.slice(0, -1);
          console.log('마지막 빈 행 제거됨');
        }
      }

      const missingInfo = {
        totalRows: cleanData.length - 1,
        totalColumns: cleanData[0].length,
        columns: []
      };

      let totalNulls = 0;
      let totalCells = 0;

      console.log('=== 결측치 분석 디버깅 ===');
      console.log('원본 행 수:', data.length - 1);
      console.log('정리된 행 수:', missingInfo.totalRows);
      console.log('총 열 수:', missingInfo.totalColumns);

      cleanData[0].forEach((header, index) => {
        let nullCount = 0;
        let nonNullCount = 0;
        
        console.log(`\n--- 열 ${index}: ${header} ---`);
        
        for (let i = 1; i < cleanData.length; i++) {
          const value = cleanData[i][index];
          
          // 결측치 판단: null, undefined, 빈 문자열, 공백만 있는 문자열
          if (value === null || value === undefined || value === '' || (typeof value === 'string' && value.trim() === '')) {
            nullCount++;
            console.log(`행 ${i}: 값="${value}" → 결측치로 판단 (nullCount: ${nullCount})`);
          } else {
            nonNullCount++;
            console.log(`행 ${i}: 값="${value}" → 유효한 값으로 판단 (nonNullCount: ${nonNullCount})`);
          }
        }

        console.log(`최종 결과: nullCount=${nullCount}, nonNullCount=${nonNullCount}`);

        totalNulls += nullCount;
        totalCells += missingInfo.totalRows;

        const nullPercentage = ((nullCount / missingInfo.totalRows) * 100).toFixed(2);
        
        missingInfo.columns.push({
          name: header,
          nullCount: nullCount,
          nonNullCount: nonNullCount,
          nullPercentage: nullPercentage,
          totalCount: missingInfo.totalRows
        });
      });

      missingInfo.totalNulls = totalNulls;
      missingInfo.totalCells = totalCells;

      console.log(`\n=== 전체 결과 ===`);
      console.log(`전체 결측치: ${totalNulls} / ${totalCells}`);
      console.log('=== 디버깅 끝 ===\n');

      return missingInfo;
    }

    function displayInfoResult(data) {
      let html = '<h3><i class="fas fa-info-circle" style="margin-right: 0.5rem;"></i>📈 데이터 정보 (pandas info)</h3>';
      html += '<div style="background: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; font-family: monospace; font-size: 0.9rem;">';
      html += `<div style="margin-bottom: 0.5rem;"><strong>RangeIndex:</strong> ${data.totalRows} entries, 0 to ${data.totalRows - 1}</div>`;
      html += `<div style="margin-bottom: 0.5rem;"><strong>Data columns (total ${data.totalColumns} columns):</strong></div>`;
      
      html += '<div class="table-container">';
      html += '<table style="width: 100%; border-collapse: collapse; margin-top: 0.5rem; min-width: 600px;">';
      html += '<thead><tr style="border-bottom: 1px solid #ddd;">';
      html += '<th style="text-align: left; padding: 4px 8px; font-weight: bold;">#</th>';
      html += '<th style="text-align: left; padding: 4px 8px; font-weight: bold;">Column</th>';
      html += '<th style="text-align: center; padding: 4px 8px; font-weight: bold;">Non-Null</th>';
      html += '<th style="text-align: center; padding: 4px 8px; font-weight: bold;">Dtype</th>';
      html += '</tr></thead><tbody>';
      
      data.columns.forEach((col, index) => {
        html += '<tr style="border-bottom: 1px solid #eee;">';
        html += `<td style="padding: 4px 8px;">${index}</td>`;
        html += `<td style="padding: 4px 8px;">${col.name}</td>`;
        html += `<td style="padding: 4px 8px; text-align: center;">${col.nonNullCount}</td>`;
        html += `<td style="padding: 4px 8px; text-align: center;">${col.dtype}</td>`;
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      html += '</div>';
      
      html += `<div style="margin-top: 1rem; padding-top: 0.5rem; border-top: 1px solid #ddd;">`;
      html += `<strong>Memory usage:</strong> ${data.memoryUsage} KB`;
      html += '</div></div>';
      
      return html;
    }

    function displayMissingDataResult(missingData, hideProcessingMenu = false) {
      let html = '<h3><i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>🔍 결측치 분석</h3>';
      html += '<div class="table-container">';
      html += '<table><thead><tr><th>열 번호</th><th>열 이름</th><th>총 개수</th><th>결측치 개수</th><th>결측치 비율</th></tr></thead><tbody>';
      
      missingData.columns.forEach((col, index) => {
        const percentage = ((col.nullCount / col.totalCount) * 100).toFixed(2);
        const rowClass = col.nullCount > 0 ? 'style="background-color: #fff3cd;"' : '';
        html += `<tr ${rowClass}>`;
        html += `<td>${index}</td>`;
        html += `<td>${col.name}</td>`;
        html += `<td>${col.totalCount}</td>`;
        html += `<td>${col.nullCount}</td>`;
        html += `<td>${percentage}%</td>`;
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      html += '</div>';
      
      const totalNulls = missingData.totalNulls;
      const totalCells = missingData.totalCells;
      const totalNullPercentage = ((totalNulls / totalCells) * 100).toFixed(2);
      
      html += `<div style="margin-top: 1rem; padding-top: 0.5rem; border-top: 1px solid #ddd;">`;
      html += `<strong>전체 결측치:</strong> ${totalNulls} / ${totalCells} (${totalNullPercentage}%)`;
      html += '</div></div>';
      
      // 결측치 처리 메뉴는 hideProcessingMenu가 false일 때만 표시
      if (!hideProcessingMenu) {
        html += '<div style="background: #fff3cd; padding: 1.5rem; border-radius: 10px; border: 1px solid #ffeaa7; margin-bottom: 1rem;">';
        html += '<h4 style="color: #856404; margin-bottom: 1rem; margin-top: 0;">';
        html += '<i class="fas fa-tools" style="margin-right: 0.5rem;"></i>🧹 결측치 처리';
        html += '</h4>';
        html += '<div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">';
        html += '<label for="missingColumnSelect" style="font-weight: bold;">처리할 열:</label>';
        html += '<select id="missingColumnSelect" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; min-width: 200px;">';
        html += '<option value="">전체 열</option>';
        
        missingData.columns.forEach((col, index) => {
          if (col.nullCount > 0) {
            html += `<option value="${index}">${index}: ${col.name} (${col.nullCount}개 결측)</option>`;
          }
        });
        
        html += '</select>';
        html += '<label for="missingMethodSelect" style="font-weight: bold;">처리 방법:</label>';
        html += '<select id="missingMethodSelect" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; min-width: 150px;" onchange="toggleCustomValueInput()">';
        html += '<option value="delete">결측치 삭제</option>';
        html += '<option value="mean">평균값 대체</option>';
        html += '<option value="mode">최빈값 대체</option>';
        html += '<option value="custom">사용자 지정 값</option>';
        html += '<option value="median">중앙값으로 대체</option>';
        html += '<option value="forward_fill">앞의 값으로 채우기</option>';
        html += '<option value="backward_fill">뒤의 값으로 채우기</option>';
        html += '</select>';
        html += '<div id="customValueContainer" style="display: none; flex: 1; min-width: 200px;">';
        html += '<label for="customValueInput" style="font-weight: bold; margin-right: 0.5rem;">지정 값:</label>';
        html += '<input type="text" id="customValueInput" placeholder="예: 0, N/A, 빈칸" style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; width: 100%;">';
        html += '</div>';
        html += '<button id="processMissing" style="padding: 0.5rem 1rem; background: #856404; color: white; border: none; border-radius: 4px; cursor: pointer;">';
        html += '<i class="fas fa-magic" style="margin-right: 0.5rem;"></i>처리';
        html += '</button>';
        html += '</div>';
        html += '<div style="margin-top: 0.5rem; font-size: 0.9rem; color: #856404;">';
        html += '<strong>참고:</strong> 결측치가 있는 열만 선택 가능합니다. 사용자 지정 값은 모든 결측치를 동일한 값으로 대체합니다.';
        html += '<br><strong>🔒 인덱스 열 보호:</strong> 1열(인덱스 열)은 데이터 구분을 위해 결측치 처리에서 제외됩니다.';
        html += '</div>';
        html += '</div>';
      }
      
      return html;
    }

    function displayDescribeResult(describeData) {
      let html = '<h3><i class="fas fa-chart-bar" style="margin-right: 0.5rem;"></i>📊 데이터 분석 결과 (pandas describe)</h3>';
      html += '<div class="table-container">';
      html += '<table><thead><tr><th>통계</th>';
      
      const columns = Object.keys(describeData);
      columns.forEach(col => {
        html += `<th>${col}</th>`;
      });
      html += '</tr></thead><tbody>';

      const stats = ['count', 'mean', 'std', 'min', '25%', '50%', '75%', 'max'];
      stats.forEach(stat => {
        html += `<tr><td style="font-weight: bold; color: #667eea;">${stat}</td>`;
        columns.forEach(col => {
          html += `<td>${describeData[col][stat]}</td>`;
        });
        html += '</tr>';
      });

      html += '</tbody></table>';
      html += '</div>';
      
      return html;
    }
    
    function displayAllResults(describeData, missingData, data) {
      globalData = data; // 전역 변수에 데이터 저장
      
      const resultDiv = document.getElementById('analysisResult');
      resultDiv.style.display = 'block';

      let html = '';
      
      // Info 결과
      const infoData = calculateInfo(data);
      html += displayInfoResult(infoData);
      
      // Describe 결과 (원본 데이터 분석)
      if (Object.keys(describeData).length === 0) {
        html += `
          <div class="error">
            <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
            분석할 수 있는 숫자형 데이터가 없습니다.
            <br><br>
            <strong>가능한 원인:</strong>
            <ul style="text-align: left; margin: 0.5rem 0;">
              <li>모든 컬럼이 문자열 데이터입니다</li>
              <li>결측치 처리 후 숫자형 컬럼이 문자열로 변경되었습니다</li>
              <li>결측치 삭제로 인해 모든 데이터가 제거되었습니다</li>
            </ul>
            <br>
            💡 <strong>해결 방법:</strong> 다른 결측치 처리 방법을 시도하거나, 원본 데이터를 다시 업로드해보세요.
          </div>
        `;
      } else {
        html += displayDescribeResult(describeData);
      }
      
      // 결측치 분석 결과 (데이터 분석 결과 아래로 이동)
      html += displayMissingDataResult(missingData);
      
      resultDiv.innerHTML = html;
      
      // PDF 출력 버튼 추가
      if (Object.keys(describeData).length > 0 || missingData.columns.some(col => col.nullCount > 0)) {
        resultDiv.innerHTML += `
          <div class="pdf-export">
            <button onclick="exportToPDF()">
              <i class="fas fa-file-pdf" style="margin-right: 0.5rem;"></i>
              📄 PDF로 출력하기
            </button>
            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
              💡 브라우저의 인쇄 대화상자에서 "대상"을 "PDF로 저장"으로 설정하세요
            </p>
          </div>
        `;
      }
      
      // 이벤트 리스너 한 번만 설정
      setupEventListeners();
    }
    
    function setupEventListeners() {
      console.log('이벤트 리스너 설정 시작');
      
      // 결측치 처리 이벤트 리스너
      const processButton = document.getElementById('processMissing');
      if (processButton) {
        // 기존 리스너 제거 후 새로 추가
        processButton.removeEventListener('click', handleProcessMissingClick);
        processButton.addEventListener('click', handleProcessMissingClick);
        console.log('결측치 처리 버튼 리스너 설정됨');
      }
      
      // 사용자 지정 값 입력 필드 이벤트 리스너
      const customValueInput = document.getElementById('customValueInput');
      if (customValueInput) {
        // 기존 리스너 제거 후 새로 추가
        customValueInput.removeEventListener('keypress', handleCustomValueKeypress);
        customValueInput.addEventListener('keypress', handleCustomValueKeypress);
        console.log('사용자 지정 값 입력 필드 리스너 설정됨');
      }
      
      // 결측치 처리 방법 선택 이벤트 리스너
      const methodSelect = document.getElementById('missingMethodSelect');
      if (methodSelect) {
        // 기존 리스너 제거 후 새로 추가
        methodSelect.removeEventListener('change', toggleCustomValueInput);
        methodSelect.addEventListener('change', toggleCustomValueInput);
        console.log('결측치 처리 방법 선택 리스너 설정됨');
      }
      
      console.log('이벤트 리스너 설정 완료');
    }
    
    // 사용자 지정 값 입력 필드 키프레스 핸들러
    function handleCustomValueKeypress(e) {
      if (e.key === 'Enter') {
        handleProcessMissingClick();
      }
    }

    function handleProcessMissingClick() {
      console.log('=== handleProcessMissingClick 시작 ===');
      
      const columnSelect = document.getElementById('missingColumnSelect');
      const methodSelect = document.getElementById('missingMethodSelect');
      
      if (!columnSelect || !methodSelect) {
        console.error('❌ 필요한 요소를 찾을 수 없습니다.');
        return;
      }
      
      const selectedColumn = columnSelect.value;
      const selectedMethod = methodSelect.value;
      
      console.log('선택된 열:', selectedColumn);
      console.log('선택된 방법:', selectedMethod);
      console.log('originalData 상태:', originalData ? '존재함' : 'null');
      
      if (!selectedMethod) {
        alert('처리 방법을 선택해주세요.');
        return;
      }
      
      // originalData가 null인지 확인
      if (!originalData || originalData.length === 0) {
        console.error('❌ originalData가 null이거나 비어있습니다.');
        alert('분석할 데이터가 없습니다. 먼저 CSV 파일을 업로드해주세요.');
        return;
      }
      
      // 사용자 지정 값 확인
      let customValue = null;
      if (selectedMethod === 'custom') {
        const customValueInput = document.getElementById('customValueInput');
        if (!customValueInput || !customValueInput.value.trim()) {
          alert('사용자 지정 값을 입력해주세요.');
          return;
        }
        customValue = customValueInput.value.trim();
      }
      
      console.log('결측치 처리 시작...');
      
      // 현재 데이터로 결측치 처리
      const processedData = processMissingData(originalData, selectedColumn, selectedMethod, customValue);
      
      console.log('처리된 데이터:', processedData ? processedData.length : 'null', '행');
      
      // 데이터가 비어있는지 확인
      if (!processedData || processedData.length <= 1) {
        alert('결측치 처리 후 분석할 데이터가 없습니다. 다른 처리 방법을 시도해주세요.');
        return;
      }
      
      // 캐시 초기화 (결측치 처리 후 데이터가 변경되었으므로)
      processedData._numericColumnsCache = null;
      
      // 처리된 데이터를 전역 변수에 저장
      globalData = processedData;
      window.processedData = processedData; // 특정 열 분석을 위해 별도 저장
      
      console.log('전역 변수에 데이터 저장 완료');
      
      // 처리된 데이터로 분석 결과 업데이트
      const describeData = calculateDescribe(processedData);
      const missingData = calculateMissingData(processedData);
      
      console.log('분석 완료, 결과 표시 시작...');
      
      // 결과 표시 업데이트
      displayProcessedResults(originalData, processedData, selectedColumn, selectedMethod, customValue);
      
      // 처리 완료 메시지
      const methodNames = {
        'delete': '결측치 삭제',
        'mean': '평균값 대체',
        'mode': '최빈값 대체',
        'custom': `사용자 지정 값 (${customValue})`,
        'median': '중앙값으로 대체',
        'forward_fill': '앞의 값으로 채우기',
        'backward_fill': '뒤의 값으로 채우기'
      };
      
      const columnName = selectedColumn === '' ? '전체 열' : 
        originalData[0][parseInt(selectedColumn)];
      
      console.log('=== handleProcessMissingClick 완료 ===');
      alert(`${columnName}에 대해 ${methodNames[selectedMethod]} 처리가 완료되었습니다.`);
    }

    // 결측치 처리 후 새로운 분석 결과 표시 함수
    function displayProcessedResults(originalData, processedData, selectedColumn, selectedMethod, customValue) {
      const resultDiv = document.getElementById('analysisResult');
      
      // 처리된 데이터로 새로운 분석 수행
      processedData._numericColumnsCache = null;
      const processedDescribeData = calculateDescribe(processedData);
      const processedMissingData = calculateMissingData(processedData);
      const processedInfoData = calculateInfo(processedData);
      
      // 원본 데이터 분석 결과
      const originalDescribeData = calculateDescribe(originalData);
      const originalMissingData = calculateMissingData(originalData);
      const originalInfoData = calculateInfo(originalData);
      
      let html = '';
      
      // 원본 데이터 Info 결과
      html += '<h3><i class="fas fa-info-circle" style="margin-right: 0.5rem;"></i>📈 원본 데이터 정보</h3>';
      html += displayInfoResult(originalInfoData);
      
      // 원본 데이터 Describe 결과
      if (Object.keys(originalDescribeData).length === 0) {
        html += `
          <div class="error">
            <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
            원본 데이터에 분석할 수 있는 숫자형 데이터가 없습니다.
          </div>
        `;
      } else {
        html += '<h3><i class="fas fa-chart-bar" style="margin-right: 0.5rem;"></i>📊 원본 데이터 분석 결과</h3>';
        html += displayDescribeResult(originalDescribeData);
      }
      
      // 원본 데이터 결측치 분석
      html += '<h3><i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>🔍 원본 데이터 결측치 분석</h3>';
      html += displayMissingDataResult(originalMissingData);
      
      // 결측치 처리 정보
      const methodNames = {
        'delete': '결측치 삭제',
        'mean': '평균값 대체',
        'mode': '최빈값 대체',
        'custom': `사용자 지정 값 (${customValue})`,
        'median': '중앙값으로 대체',
        'forward_fill': '앞의 값으로 채우기',
        'backward_fill': '뒤의 값으로 채우기'
      };
      
      const columnName = selectedColumn === '' ? '전체 열' : 
        originalData[0][parseInt(selectedColumn)];
      
      html += `
        <div style="background: #e8f5e8; padding: 1.5rem; border-radius: 10px; border: 1px solid #4caf50; margin: 2rem 0;">
          <h3 style="color: #2e7d32; margin-top: 0; margin-bottom: 1rem;">
            <i class="fas fa-check-circle" style="margin-right: 0.5rem;"></i>✅ 결측치 처리 완료
          </h3>
          <div style="color: #2e7d32; font-weight: bold; margin-bottom: 1rem;">
            처리 대상: ${columnName}<br>
            처리 방법: ${methodNames[selectedMethod]}<br>
            처리된 행 수: ${originalData.length - 1} → ${processedData.length - 1}
          </div>
          <div style="font-size: 0.9rem; color: #2e7d32;">
            💡 아래에서 처리 후 데이터 분석 결과를 확인하세요
          </div>
        </div>
      `;
      
      // 처리된 데이터 Info 결과
      html += '<h3><i class="fas fa-info-circle" style="margin-right: 0.5rem;"></i>📈 처리 후 데이터 정보</h3>';
      html += displayInfoResult(processedInfoData);
      
      // 처리된 데이터 Describe 결과
      if (Object.keys(processedDescribeData).length === 0) {
        html += `
          <div class="error">
            <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
            처리 후 데이터에 분석할 수 있는 숫자형 데이터가 없습니다.
          </div>
        `;
      } else {
        html += '<h3><i class="fas fa-chart-bar" style="margin-right: 0.5rem;"></i>📊 처리 후 데이터 분석 결과</h3>';
        html += displayDescribeResult(processedDescribeData);
      }
      
      // 처리된 데이터 결측치 분석 (결측치 처리 메뉴 숨김)
      html += '<h3><i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>🔍 처리 후 데이터 결측치 분석</h3>';
      html += displayMissingDataResult(processedMissingData, true);
      
      resultDiv.innerHTML = html;
      
      // PDF 출력 버튼 추가
      if (Object.keys(processedDescribeData).length > 0 || processedMissingData.columns.some(col => col.nullCount > 0)) {
        resultDiv.innerHTML += `
          <div class="pdf-export">
            <button onclick="exportToPDF()">
              <i class="fas fa-file-pdf" style="margin-right: 0.5rem;"></i>
              📄 PDF로 출력하기
            </button>
            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">
              💡 브라우저의 인쇄 대화상자에서 "대상"을 "PDF로 저장"으로 설정하세요
            </p>
          </div>
        `;
      }
      
      // 이벤트 리스너 설정
      setupEventListeners();
    }

    function handleFileUpload(file) {
      console.log('handleFileUpload 시작:', file.name, file.size);
      
      const loadingIndicator = document.getElementById('loadingIndicator');
      const resultDiv = document.getElementById('analysisResult');
      
      loadingIndicator.style.display = 'block';
      resultDiv.style.display = 'none';

      // 파일 크기 체크 (50MB 제한)
      if (file.size > 50 * 1024 * 1024) {
        console.log('파일이 너무 큼:', file.size);
        loadingIndicator.style.display = 'none';
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `
          <div class="error">
            <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
            파일이 너무 큽니다. 50MB 이하의 파일을 사용해주세요.
          </div>
        `;
        return;
      }

      // FileReader를 사용한 직접 파일 읽기
      const reader = new FileReader();
      
      reader.onload = function(e) {
        console.log('파일 읽기 완료, 크기:', e.target.result.byteLength);
        const arrayBuffer = e.target.result;
        
        // BOM 제거 함수
        function removeBOM(content) {
          // UTF-8 BOM 제거
          if (content.charCodeAt(0) === 0xFEFF) {
            return content.slice(1);
          }
          // UTF-16 LE BOM 제거
          if (content.charCodeAt(0) === 0xFFFE) {
            return content.slice(1);
          }
          // UTF-16 BE BOM 제거
          if (content.charCodeAt(0) === 0xFEFF && content.charCodeAt(1) === 0x0000) {
            return content.slice(2);
          }
          return content;
        }
        
        // 한글 깨짐 감지 함수 (최적화)
        function isKoreanBroken(text) {
          if (!text) return false;
          // 주요 깨진 패턴만 체크
          const brokenPatterns = [/ï»¿/, /ë/, /ì/, /í/, /î/, /ï/];
          return brokenPatterns.some(pattern => pattern.test(text));
        }
        
        // 인코딩 시도 (UTF-8 우선)
        const encodings = ['UTF-8', 'EUC-KR', 'CP949'];
        let currentEncodingIndex = 0;
        let lastResults = null;

        function tryParseWithEncoding() {
          console.log('인코딩 시도:', encodings[currentEncodingIndex]);
          
          if (currentEncodingIndex >= encodings.length) {
            console.log('모든 인코딩 시도 실패');
            loadingIndicator.style.display = 'none';
            
            // 모든 인코딩 시도 후에도 실패하면 마지막 결과를 사용
            if (lastResults && lastResults.data.length > 0) {
              console.log('마지막 결과 사용:', lastResults.data.length, '행');
              // 파일명 저장
              lastResults.data._fileName = file.name;
              // 원본 데이터 보존
              originalData = JSON.parse(JSON.stringify(lastResults.data));
              // 데이터 캐시 초기화
              lastResults.data._numericColumnsCache = null;
              const describeData = calculateDescribe(lastResults.data);
              displayAllResults(describeData, calculateMissingData(lastResults.data), lastResults.data);
            } else {
              resultDiv.style.display = 'block';
              resultDiv.innerHTML = `
                <div class="error">
                  <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
                  CSV 파일을 읽을 수 없습니다. 파일을 UTF-8로 저장해주세요.
                </div>
              `;
            }
            return;
          }

          const encoding = encodings[currentEncodingIndex];
          
          try {
            const decoder = new TextDecoder(encoding);
            let content = decoder.decode(arrayBuffer);
            
            // BOM 제거
            content = removeBOM(content);
            console.log('디코딩된 내용 길이:', content.length);
            
            Papa.parse(content, {
              complete: function(results) {
                console.log('Papa.parse 완료:', results.data.length, '행, 오류:', results.errors.length);
                lastResults = results;
                
                if (results.errors.length > 0) {
                  console.log('파싱 오류:', results.errors);
                  // 오류가 있으면 다음 인코딩 시도
                  currentEncodingIndex++;
                  tryParseWithEncoding();
                  return;
                }
                
                // 데이터가 제대로 파싱되었는지 확인
                if (results.data.length === 0 || results.data[0].length === 0) {
                  console.log('빈 데이터');
                  currentEncodingIndex++;
                  tryParseWithEncoding();
                  return;
                }
                
                // 한글이 깨졌는지 확인 (첫 번째 셀에서 확인)
                const firstCell = results.data[0][0];
                if (firstCell && isKoreanBroken(firstCell)) {
                  console.log('한글 깨짐 감지:', firstCell);
                  currentEncodingIndex++;
                  tryParseWithEncoding();
                  return;
                }
                
                // 성공적으로 파싱된 경우
                console.log('파싱 성공!');
                loadingIndicator.style.display = 'none';
                
                // 파일명 저장
                results.data._fileName = file.name;
                
                // 원본 데이터 보존
                originalData = JSON.parse(JSON.stringify(results.data));
                
                // 데이터 캐시 초기화
                results.data._numericColumnsCache = null;
                const describeData = calculateDescribe(results.data);
                displayAllResults(describeData, calculateMissingData(results.data), results.data);
              },
              error: function(error) {
                console.log('Papa.parse 오류:', error);
                currentEncodingIndex++;
                tryParseWithEncoding();
              }
            });
          } catch (error) {
            console.log('디코딩 오류:', error);
            currentEncodingIndex++;
            tryParseWithEncoding();
          }
        }

        tryParseWithEncoding();
      };
      
      reader.onerror = function() {
        console.log('FileReader 오류');
        loadingIndicator.style.display = 'none';
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `
          <div class="error">
            <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
            파일을 읽는 중 오류가 발생했습니다.
          </div>
        `;
      };
      
      // 파일을 ArrayBuffer로 읽기
      reader.readAsArrayBuffer(file);
    }

    // 결측치 처리 함수들
    function processMissingData(data, columnIndex, method, customValue = null) {
      console.log('=== processMissingData 시작 ===');
      console.log('입력 데이터:', data ? data.length : 'null', '행');
      console.log('선택된 열:', columnIndex);
      console.log('처리 방법:', method);
      
      const processedData = JSON.parse(JSON.stringify(data)); // 깊은 복사
      
      if (columnIndex === '') {
        // 전체 열 처리
        console.log('전체 열 처리 시작');
        if (method === 'delete') {
          // delete 메서드는 특별 처리 - 결측치가 있는 행을 모두 제거
          console.log('delete 메서드로 전체 열 처리');
          const rowsToDelete = new Set();
          
          // 결측치가 있는 행들을 찾기
          for (let i = 1; i < processedData.length; i++) {
            for (let col = 0; col < processedData[0].length; col++) {
              if (!processedData[i][col] || processedData[i][col].toString().trim() === '') {
                rowsToDelete.add(i);
                break; // 한 행에 결측치가 있으면 해당 행은 삭제 대상
              }
            }
          }
          
          // 결측치가 있는 행들을 뒤에서부터 삭제 (인덱스 변경 방지)
          const rowsToDeleteArray = Array.from(rowsToDelete).sort((a, b) => b - a);
          rowsToDeleteArray.forEach(rowIndex => {
            processedData.splice(rowIndex, 1);
          });
          
          console.log(`${rowsToDeleteArray.length}개 행 삭제됨`);
        } else {
          // 다른 메서드들은 각 열을 개별적으로 처리
          console.log('각 열을 개별적으로 처리');
          for (let col = 0; col < processedData[0].length; col++) {
            // 1열(인덱스 열)은 보호 - 결측치 처리 건너뛰기
            if (col === 0) {
              console.log(`열 ${col} (인덱스 열) - 결측치 처리 건너뛰기`);
              continue;
            }
            console.log(`열 ${col} 처리 시작`);
            processColumn(processedData, col, method, customValue);
            console.log(`열 ${col} 처리 완료`);
          }
        }
      } else {
        // 특정 열 처리
        console.log('특정 열 처리 시작:', columnIndex);
        processColumn(processedData, parseInt(columnIndex), method, customValue);
      }
      
      console.log('처리된 데이터:', processedData.length, '행');
      console.log('=== processMissingData 완료 ===');
      return processedData;
    }
    
    function processColumn(data, columnIndex, method, customValue = null) {
      console.log(`=== processColumn 시작: 열 ${columnIndex}, 방법 ${method} ===`);
      
      const values = [];
      
      // 유효한 값들 수집
      for (let i = 1; i < data.length; i++) {
        if (data[i][columnIndex] && data[i][columnIndex].toString().trim() !== '') {
          values.push(data[i][columnIndex]);
        }
      }
      
      console.log(`열 ${columnIndex}: 유효한 값 ${values.length}개`);
      
      if (values.length === 0) {
        console.log(`열 ${columnIndex}: 처리할 값이 없음`);
        return; // 처리할 값이 없음
      }
      
      let replacementValue = '';
      let isNumericReplacement = false;
      
      // 해당 컬럼이 숫자형인지 먼저 확인
      const numericValues = values.filter(v => !isNaN(parseFloat(v))).map(v => parseFloat(v));
      const isNumericColumn = numericValues.length > 0 && numericValues.length === values.length;
      
      console.log(`컬럼 ${columnIndex} 분석: 총 ${values.length}개 값, 숫자형 ${numericValues.length}개, 숫자형 컬럼=${isNumericColumn}`);
      
      switch (method) {
        case 'mean':
          if (numericValues.length > 0) {
            const mean = numericValues.reduce((a, b) => a + b, 0) / numericValues.length;
            replacementValue = mean; // 숫자로 유지
            isNumericReplacement = true;
            console.log(`평균값 계산: ${mean}`);
          } else {
            // 숫자가 아니면 최빈값 사용
            replacementValue = getMode(values);
            console.log(`숫자가 아니므로 최빈값 사용: ${replacementValue}`);
          }
          break;
          
        case 'mode':
          if (isNumericColumn) {
            // 숫자형 컬럼인 경우 숫자형 최빈값 계산
            const mode = getNumericMode(numericValues);
            replacementValue = mode;
            isNumericReplacement = true;
            console.log(`숫자형 최빈값: ${mode}`);
          } else {
            // 문자열 컬럼인 경우 문자열 최빈값 사용
            replacementValue = getMode(values);
            console.log(`문자열 최빈값: ${replacementValue}`);
          }
          break;
          
        case 'custom':
          // 사용자 지정 값 사용
          if (customValue !== null) {
            if (isNumericColumn && !isNaN(parseFloat(customValue))) {
              // 숫자형 컬럼이고 사용자 지정 값이 숫자인 경우
              replacementValue = parseFloat(customValue);
              isNumericReplacement = true;
              console.log(`숫자형 사용자 지정 값: ${replacementValue}`);
            } else {
              // 문자열로 처리
              replacementValue = customValue;
              console.log(`문자열 사용자 지정 값: ${replacementValue}`);
            }
          } else {
            // 기본값으로 빈 문자열 사용
            replacementValue = '';
            console.log('기본값 사용: 빈 문자열');
          }
          break;
          
        case 'median':
          // 중앙값으로 대체 (pandas fillna(df.median())과 유사)
          if (numericValues.length > 0) {
            const sortedValues = [...numericValues].sort((a, b) => a - b);
            const mid = Math.floor(sortedValues.length / 2);
            replacementValue = sortedValues.length % 2 === 0 
              ? (sortedValues[mid - 1] + sortedValues[mid]) / 2 
              : sortedValues[mid];
            isNumericReplacement = true;
            console.log(`중앙값: ${replacementValue}`);
          } else {
            replacementValue = getMode(values);
            console.log(`숫자가 아니므로 최빈값 사용: ${replacementValue}`);
          }
          break;
          
        case 'forward_fill':
          // 앞의 값으로 채우기 (pandas fillna(method='ffill')과 유사)
          console.log('앞의 값으로 채우기 시작');
          for (let i = 1; i < data.length; i++) {
            if (!data[i][columnIndex] || data[i][columnIndex].toString().trim() === '') {
              // 앞의 유효한 값 찾기
              for (let j = i - 1; j >= 1; j--) {
                if (data[j][columnIndex] && data[j][columnIndex].toString().trim() !== '') {
                  data[i][columnIndex] = data[j][columnIndex];
                  console.log(`행 ${i}를 행 ${j}의 값으로 채움: ${data[j][columnIndex]}`);
                  break;
                }
              }
            }
          }
          console.log('앞의 값으로 채우기 완료');
          break;
          
        case 'backward_fill':
          // 뒤의 값으로 채우기 (pandas fillna(method='bfill')과 유사)
          console.log('뒤의 값으로 채우기 시작');
          for (let i = data.length - 1; i >= 1; i--) {
            if (!data[i][columnIndex] || data[i][columnIndex].toString().trim() === '') {
              // 뒤의 유효한 값 찾기
              for (let j = i + 1; j < data.length; j++) {
                if (data[j][columnIndex] && data[j][columnIndex].toString().trim() !== '') {
                  data[i][columnIndex] = data[j][columnIndex];
                  console.log(`행 ${i}를 행 ${j}의 값으로 채움: ${data[j][columnIndex]}`);
                  break;
                }
              }
            }
          }
          console.log('뒤의 값으로 채우기 완료');
          break;
          
        default:
          console.error(`알 수 없는 처리 방법: ${method}`);
          return;
      }
      
      // 결측치를 대체값으로 교체
      let replacedCount = 0;
      for (let i = 1; i < data.length; i++) {
        if (!data[i][columnIndex] || data[i][columnIndex].toString().trim() === '') {
          data[i][columnIndex] = replacementValue;
          replacedCount++;
        }
      }
      
      console.log(`컬럼 ${columnIndex} 결측치 처리 완료: ${method}, 대체값=${replacementValue}, 숫자형=${isNumericReplacement}, 교체된 셀=${replacedCount}개`);
      console.log(`=== processColumn 완료 ===`);
    }
    
    // 숫자형 데이터의 최빈값 계산 함수
    function getNumericMode(values) {
      const frequency = {};
      let maxFreq = 0;
      let mode = values[0];
      
      values.forEach(value => {
        frequency[value] = (frequency[value] || 0) + 1;
        if (frequency[value] > maxFreq) {
          maxFreq = frequency[value];
          mode = value;
        }
      });
      
      return mode;
    }

    // 문자열 데이터의 최빈값 계산 함수
    function getMode(values) {
      const frequency = {};
      let maxFreq = 0;
      let mode = values[0];
      
      values.forEach(value => {
        frequency[value] = (frequency[value] || 0) + 1;
        if (frequency[value] > maxFreq) {
          maxFreq = frequency[value];
          mode = value;
        }
      });
      
      return mode;
    }

    // 사용자 지정 값 입력 필드 토글 함수
    function toggleCustomValueInput() {
      const methodSelect = document.getElementById('missingMethodSelect');
      const customValueContainer = document.getElementById('customValueContainer');
      const customValueInput = document.getElementById('customValueInput');
      
      if (methodSelect && customValueContainer) {
        if (methodSelect.value === 'custom') {
          customValueContainer.style.display = 'flex';
          customValueInput.focus();
        } else {
          customValueContainer.style.display = 'none';
          customValueInput.value = '';
        }
      }
    }

    // PDF 출력 함수
    function exportToPDF() {
      // 현재 날짜와 시간을 파일명에 포함
      const now = new Date();
      const dateStr = now.getFullYear() + 
                     String(now.getMonth() + 1).padStart(2, '0') + 
                     String(now.getDate()).padStart(2, '0') + '_' +
                     String(now.getHours()).padStart(2, '0') + 
                     String(now.getMinutes()).padStart(2, '0');
      
      // 파일명 설정 (업로드된 파일명이 있으면 사용)
      let fileName = 'CSV_분석결과';
      if (globalData && globalData._fileName) {
        fileName = globalData._fileName.replace('.csv', '') + '_분석결과';
      }
      fileName += '_' + dateStr;
      
      // 인쇄 대화상자 열기
      const printWindow = window.open('', '_blank');
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${fileName}</title>
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Malgun Gothic', '맑은 고딕', 'Noto Sans KR', sans-serif;
              margin: 0;
              padding: 20px;
              color: #333;
            }
            
            .container {
              max-width: 100%;
              background: white;
            }
            
            .header {
              background: #667eea;
              color: white;
              padding: 2rem;
              text-align: center;
              margin-bottom: 2rem;
            }
            
            .header h1 {
              margin: 0;
              font-size: 2rem;
              margin-bottom: 0.5rem;
            }
            
            .header p {
              margin: 0;
              opacity: 0.9;
            }
            
            .analysis-result {
              background: white;
              padding: 0;
            }
            
            .analysis-result h3 {
              color: #667eea;
              margin-top: 0;
              margin-bottom: 1rem;
              text-align: center;
              page-break-after: avoid;
            }
            
            .analysis-result table {
              width: 100%;
              border-collapse: collapse;
              background: white;
              border: 1px solid #ddd;
              margin-bottom: 1rem;
              page-break-inside: avoid;
            }
            
            .analysis-result th {
              background: #667eea;
              color: white;
              padding: 12px 8px;
              text-align: center;
              font-weight: 600;
            }
            
            .analysis-result td {
              padding: 10px 8px;
              text-align: center;
              border-bottom: 1px solid #eee;
            }
            
            .table-container {
              border: 1px solid #ddd;
              margin-bottom: 1rem;
            }
            
            .error {
              background: #ffe6e6;
              color: #d63031;
              padding: 1rem;
              border-radius: 8px;
              border: 1px solid #ff7675;
              text-align: center;
            }
            
            @media print {
              body {
                margin: 0;
                padding: 10px;
              }
              
              .header {
                background: #667eea !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
              }
              
              .analysis-result th {
                background: #667eea !important;
                color: white !important;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
              }
            }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>📊 CSV 데이터 분석 결과</h1>
              <p>생성일시: ${now.getFullYear()}년 ${now.getMonth() + 1}월 ${now.getDate()}일 ${now.getHours()}시 ${now.getMinutes()}분</p>
            </div>
            <div class="analysis-result">
              ${document.getElementById('analysisResult').innerHTML}
            </div>
          </div>
        </body>
        </html>
      `);
      
      printWindow.document.close();
      
      // 잠시 후 인쇄 대화상자 열기
      setTimeout(() => {
        printWindow.print();
        // 인쇄 후 창 닫기 (사용자가 취소할 수도 있으므로 바로 닫지 않음)
        printWindow.onafterprint = function() {
          printWindow.close();
        };
      }, 500);
    }

    // 이벤트 리스너들
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded 이벤트 발생');
      
      // 파일 업로드 이벤트 리스너
      document.getElementById('fileUpload').addEventListener('click', () => {
        console.log('파일 업로드 클릭됨');
        document.getElementById('csvFile').click();
      });

      document.getElementById('csvFile').addEventListener('change', (e) => {
        console.log('파일 선택됨');
        const file = e.target.files[0];
        if (file) {
          console.log('파일 정보:', file.name, file.type, file.size);
          handleFileUpload(file);
        }
      });

      // 드래그 앤 드롭 기능
      const fileUpload = document.getElementById('fileUpload');
      
      fileUpload.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileUpload.classList.add('dragover');
      });

      fileUpload.addEventListener('dragleave', () => {
        fileUpload.classList.remove('dragover');
      });

      fileUpload.addEventListener('drop', (e) => {
        e.preventDefault();
        fileUpload.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        console.log('드롭된 파일들:', files);
        
        if (files.length > 0) {
          const file = files[0];
          console.log('드롭된 파일:', file.name, file.type, file.size);
          
          // 파일 타입 체크 개선 (확장자도 확인)
          const isCSV = file.type === 'text/csv' || 
                       file.name.toLowerCase().endsWith('.csv') ||
                       file.type === 'application/vnd.ms-excel' ||
                       file.type === 'application/csv';
          
          if (isCSV) {
            handleFileUpload(file);
          } else {
            alert('CSV 파일만 업로드 가능합니다. (파일명: ' + file.name + ', 타입: ' + file.type + ')');
          }
        }
      });
      
      console.log('이벤트 리스너 설정 완료');
    });
  </script>
</body>
</html> 